---
phase: 18-lineup-boat-improvements
plan: 07
type: execute
wave: 3
depends_on: ["18-02", "18-03", "18-04", "18-05", "18-06"]
files_modified:
  - src/v2/hooks/useRiggingProfiles.ts
  - src/v2/hooks/useLineupTemplates.ts
  - src/v2/hooks/useEquipment.ts
  - src/v2/hooks/useLineupSearch.ts
autonomous: true

must_haves:
  truths:
    - "TanStack Query hooks exist for all Phase 18 APIs"
    - "Hooks use query key factories for cache management"
    - "Mutations invalidate related queries"
  artifacts:
    - path: "src/v2/hooks/useRiggingProfiles.ts"
      provides: "Hooks for rigging profile CRUD"
      exports: ["useRiggingProfile", "useTeamRiggingProfiles", "useSaveRiggingProfile"]
    - path: "src/v2/hooks/useLineupTemplates.ts"
      provides: "Hooks for lineup template CRUD"
      exports: ["useLineupTemplates", "useApplyTemplate", "useSaveTemplate"]
    - path: "src/v2/hooks/useEquipment.ts"
      provides: "Hooks for equipment assignment and conflicts"
      exports: ["useEquipmentAvailability", "useCheckConflicts", "useCreateEquipmentAssignment"]
    - path: "src/v2/hooks/useLineupSearch.ts"
      provides: "Hook for historical lineup search"
      exports: ["useLineupSearch"]
  key_links:
    - from: "src/v2/hooks/useRiggingProfiles.ts"
      to: "/api/v1/rigging"
      via: "TanStack Query fetch"
      pattern: "api/v1/rigging"
    - from: "src/v2/hooks/useEquipment.ts"
      to: "/api/v1/equipment"
      via: "TanStack Query fetch"
      pattern: "api/v1/equipment"
---

<objective>
Create TanStack Query hooks for all Phase 18 APIs.

Purpose: Provide type-safe, cached data access for rigging, templates, equipment, and lineup search.
Output: Four hook files with query/mutation functions for each API domain.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-lineup-boat-improvements/18-RESEARCH.md
@src/v2/types/rigging.ts
@src/v2/types/lineupTemplate.ts
@src/v2/types/equipment.ts
@src/v2/hooks/useAthletes.ts
@src/v2/hooks/useErgTests.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rigging hooks</name>
  <files>src/v2/hooks/useRiggingProfiles.ts</files>
  <action>
Create `src/v2/hooks/useRiggingProfiles.ts` with:

```typescript
/**
 * Rigging Profile Hooks - Phase 18 BOAT-02
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import useAuthStore from '@/store/authStore';
import type { RiggingProfile, RiggingProfileInput, RiggingDefaults } from '@v2/types/rigging';

// Query key factory
export const riggingKeys = {
  all: ['rigging'] as const,
  defaults: () => [...riggingKeys.all, 'defaults'] as const,
  profiles: () => [...riggingKeys.all, 'profiles'] as const,
  profile: (shellId: string) => [...riggingKeys.all, 'profile', shellId] as const,
};

/**
 * Get default rigging values for all boat classes
 */
export function useDefaultRigging() {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: riggingKeys.defaults(),
    queryFn: async (): Promise<Record<string, RiggingDefaults>> => {
      const response = await authenticatedFetch('/api/v1/rigging/defaults');
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Failed to fetch defaults');
      return data.data.defaults;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId,
    staleTime: Infinity, // Defaults never change
  });
}

/**
 * Get all team rigging profiles
 */
export function useTeamRiggingProfiles() {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: riggingKeys.profiles(),
    queryFn: async (): Promise<RiggingProfile[]> => {
      const response = await authenticatedFetch('/api/v1/rigging');
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Failed to fetch profiles');
      return data.data.profiles;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

/**
 * Get rigging profile for a specific shell
 */
export function useRiggingProfile(shellId: string | null) {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: riggingKeys.profile(shellId || ''),
    queryFn: async (): Promise<RiggingProfile & { isCustom: boolean }> => {
      const response = await authenticatedFetch(`/api/v1/rigging/shell/${shellId}`);
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Failed to fetch profile');
      return data.data.profile;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId && !!shellId,
    staleTime: 5 * 60 * 1000,
  });
}

/**
 * Save (create/update) rigging profile
 */
export function useSaveRiggingProfile() {
  const { authenticatedFetch } = useAuthStore();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      shellId,
      data,
    }: {
      shellId: string;
      data: RiggingProfileInput;
    }): Promise<RiggingProfile> => {
      const response = await authenticatedFetch(`/api/v1/rigging/shell/${shellId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to save profile');
      return result.data.profile;
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: riggingKeys.profile(variables.shellId) });
      queryClient.invalidateQueries({ queryKey: riggingKeys.profiles() });
    },
  });
}

/**
 * Delete rigging profile (revert to defaults)
 */
export function useDeleteRiggingProfile() {
  const { authenticatedFetch } = useAuthStore();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (shellId: string): Promise<void> => {
      const response = await authenticatedFetch(`/api/v1/rigging/shell/${shellId}`, {
        method: 'DELETE',
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to delete profile');
    },
    onSuccess: (_, shellId) => {
      queryClient.invalidateQueries({ queryKey: riggingKeys.profile(shellId) });
      queryClient.invalidateQueries({ queryKey: riggingKeys.profiles() });
    },
  });
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/v2/hooks/useRiggingProfiles.ts` - should compile without errors.</verify>
  <done>Rigging hooks created with query key factory and CRUD operations.</done>
</task>

<task type="auto">
  <name>Task 2: Create template and equipment hooks</name>
  <files>src/v2/hooks/useLineupTemplates.ts, src/v2/hooks/useEquipment.ts</files>
  <action>
Create `src/v2/hooks/useLineupTemplates.ts`:

```typescript
/**
 * Lineup Template Hooks - Phase 18 LINEUP-03
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import useAuthStore from '@/store/authStore';
import type {
  LineupTemplate,
  LineupTemplateInput,
  LineupTemplateUpdateInput,
  AppliedTemplate,
} from '@v2/types/lineupTemplate';

// Query key factory
export const templateKeys = {
  all: ['lineup-templates'] as const,
  lists: () => [...templateKeys.all, 'list'] as const,
  list: (boatClass?: string) => [...templateKeys.lists(), { boatClass }] as const,
  details: () => [...templateKeys.all, 'detail'] as const,
  detail: (id: string) => [...templateKeys.details(), id] as const,
};

/**
 * Get all templates, optionally filtered by boat class
 */
export function useLineupTemplates(boatClass?: string) {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: templateKeys.list(boatClass),
    queryFn: async (): Promise<LineupTemplate[]> => {
      const url = boatClass
        ? `/api/v1/lineup-templates?boatClass=${encodeURIComponent(boatClass)}`
        : '/api/v1/lineup-templates';
      const response = await authenticatedFetch(url);
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Failed to fetch templates');
      return data.data.templates;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId,
    staleTime: 5 * 60 * 1000,
  });
}

/**
 * Get a single template
 */
export function useLineupTemplate(templateId: string | null) {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: templateKeys.detail(templateId || ''),
    queryFn: async (): Promise<LineupTemplate> => {
      const response = await authenticatedFetch(`/api/v1/lineup-templates/${templateId}`);
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Failed to fetch template');
      return data.data.template;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId && !!templateId,
    staleTime: 5 * 60 * 1000,
  });
}

/**
 * Create a new template
 */
export function useCreateTemplate() {
  const { authenticatedFetch } = useAuthStore();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: LineupTemplateInput): Promise<LineupTemplate> => {
      const response = await authenticatedFetch('/api/v1/lineup-templates', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to create template');
      return result.data.template;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: templateKeys.lists() });
    },
  });
}

/**
 * Create template from existing lineup
 */
export function useCreateTemplateFromLineup() {
  const { authenticatedFetch } = useAuthStore();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      lineupId,
      name,
      isDefault,
    }: {
      lineupId: string;
      name: string;
      isDefault?: boolean;
    }): Promise<LineupTemplate> => {
      const response = await authenticatedFetch('/api/v1/lineup-templates/from-lineup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lineupId, name, isDefault }),
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to create template');
      return result.data.template;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: templateKeys.lists() });
    },
  });
}

/**
 * Update a template
 */
export function useUpdateTemplate() {
  const { authenticatedFetch } = useAuthStore();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      templateId,
      data,
    }: {
      templateId: string;
      data: LineupTemplateUpdateInput;
    }): Promise<LineupTemplate> => {
      const response = await authenticatedFetch(`/api/v1/lineup-templates/${templateId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to update template');
      return result.data.template;
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: templateKeys.detail(variables.templateId) });
      queryClient.invalidateQueries({ queryKey: templateKeys.lists() });
    },
  });
}

/**
 * Delete a template
 */
export function useDeleteTemplate() {
  const { authenticatedFetch } = useAuthStore();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (templateId: string): Promise<void> => {
      const response = await authenticatedFetch(`/api/v1/lineup-templates/${templateId}`, {
        method: 'DELETE',
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to delete template');
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: templateKeys.lists() });
    },
  });
}

/**
 * Apply a template to get assignments
 */
export function useApplyTemplate() {
  const { authenticatedFetch } = useAuthStore();

  return useMutation({
    mutationFn: async (templateId: string): Promise<AppliedTemplate> => {
      const response = await authenticatedFetch(`/api/v1/lineup-templates/${templateId}/apply`, {
        method: 'POST',
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to apply template');
      return result.data;
    },
  });
}
```

Create `src/v2/hooks/useEquipment.ts`:

```typescript
/**
 * Equipment Hooks - Phase 18 BOAT-03, BOAT-04
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import useAuthStore from '@/store/authStore';
import type {
  EquipmentAssignment,
  EquipmentAssignmentInput,
  EquipmentConflict,
  EquipmentAvailability,
} from '@v2/types/equipment';

// Query key factory
export const equipmentKeys = {
  all: ['equipment'] as const,
  availability: (date: string, excludeLineupId?: string) =>
    [...equipmentKeys.all, 'availability', date, excludeLineupId] as const,
  assignments: (date: string) => [...equipmentKeys.all, 'assignments', date] as const,
  lineupAssignments: (lineupId: string) =>
    [...equipmentKeys.all, 'lineup-assignments', lineupId] as const,
};

/**
 * Get equipment availability for a date
 */
export function useEquipmentAvailability(date: string, excludeLineupId?: string) {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: equipmentKeys.availability(date, excludeLineupId),
    queryFn: async (): Promise<EquipmentAvailability> => {
      let url = `/api/v1/equipment/availability?date=${encodeURIComponent(date)}`;
      if (excludeLineupId) {
        url += `&excludeLineupId=${encodeURIComponent(excludeLineupId)}`;
      }
      const response = await authenticatedFetch(url);
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Failed to fetch availability');
      return data.data;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId && !!date,
    staleTime: 30 * 1000, // 30 seconds - equipment status can change frequently
  });
}

/**
 * Get assignments for a date
 */
export function useEquipmentAssignments(date: string) {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: equipmentKeys.assignments(date),
    queryFn: async (): Promise<EquipmentAssignment[]> => {
      const response = await authenticatedFetch(
        `/api/v1/equipment/assignments?date=${encodeURIComponent(date)}`
      );
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Failed to fetch assignments');
      return data.data.assignments;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId && !!date,
    staleTime: 30 * 1000,
  });
}

/**
 * Get assignments for a lineup
 */
export function useLineupEquipmentAssignments(lineupId: string | null) {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: equipmentKeys.lineupAssignments(lineupId || ''),
    queryFn: async (): Promise<EquipmentAssignment[]> => {
      const response = await authenticatedFetch(
        `/api/v1/equipment/assignments/lineup/${lineupId}`
      );
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Failed to fetch assignments');
      return data.data.assignments;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId && !!lineupId,
    staleTime: 30 * 1000,
  });
}

/**
 * Create equipment assignment
 */
export function useCreateEquipmentAssignment() {
  const { authenticatedFetch } = useAuthStore();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: EquipmentAssignmentInput): Promise<EquipmentAssignment> => {
      const response = await authenticatedFetch('/api/v1/equipment/assignments', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to create assignment');
      return result.data.assignment;
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: equipmentKeys.availability(variables.assignedDate),
      });
      queryClient.invalidateQueries({
        queryKey: equipmentKeys.assignments(variables.assignedDate),
      });
      if (variables.lineupId) {
        queryClient.invalidateQueries({
          queryKey: equipmentKeys.lineupAssignments(variables.lineupId),
        });
      }
    },
  });
}

/**
 * Delete equipment assignment
 */
export function useDeleteEquipmentAssignment() {
  const { authenticatedFetch } = useAuthStore();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (assignmentId: string): Promise<void> => {
      const response = await authenticatedFetch(`/api/v1/equipment/assignments/${assignmentId}`, {
        method: 'DELETE',
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to delete assignment');
    },
    onSuccess: () => {
      // Invalidate all equipment queries since we don't know the date/lineup
      queryClient.invalidateQueries({ queryKey: equipmentKeys.all });
    },
  });
}

/**
 * Check for equipment conflicts
 */
export function useCheckConflicts() {
  const { authenticatedFetch } = useAuthStore();

  return useMutation({
    mutationFn: async ({
      date,
      shellIds,
      oarSetIds,
      excludeLineupId,
    }: {
      date: string;
      shellIds?: string[];
      oarSetIds?: string[];
      excludeLineupId?: string;
    }): Promise<{ conflicts: EquipmentConflict[]; hasConflicts: boolean }> => {
      const response = await authenticatedFetch('/api/v1/equipment/check-conflicts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ date, shellIds, oarSetIds, excludeLineupId }),
      });
      const result = await response.json();
      if (!result.success) throw new Error(result.error?.message || 'Failed to check conflicts');
      return result.data;
    },
  });
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/v2/hooks/useLineupTemplates.ts src/v2/hooks/useEquipment.ts` - should compile without errors.</verify>
  <done>Template and equipment hooks created.</done>
</task>

<task type="auto">
  <name>Task 3: Create lineup search hook</name>
  <files>src/v2/hooks/useLineupSearch.ts</files>
  <action>
Create `src/v2/hooks/useLineupSearch.ts`:

```typescript
/**
 * Lineup Search Hook - Phase 18 LINEUP-02
 */

import { useQuery, keepPreviousData } from '@tanstack/react-query';
import useAuthStore from '@/store/authStore';
import type { LineupSearchFilters, LineupSearchResult } from '@v2/types/equipment';

// Query key factory
export const lineupSearchKeys = {
  all: ['lineup-search'] as const,
  search: (filters: LineupSearchFilters) => [...lineupSearchKeys.all, filters] as const,
};

interface SearchResult {
  lineups: LineupSearchResult[];
  total: number;
  limit: number;
  offset: number;
}

/**
 * Search historical lineups with multi-criteria filtering
 */
export function useLineupSearch(filters: LineupSearchFilters, enabled = true) {
  const { authenticatedFetch, isAuthenticated, isInitialized, activeTeamId } =
    useAuthStore();

  return useQuery({
    queryKey: lineupSearchKeys.search(filters),
    queryFn: async (): Promise<SearchResult> => {
      const params = new URLSearchParams();

      if (filters.athleteIds?.length) {
        params.append('athleteIds', filters.athleteIds.join(','));
      }
      if (filters.minAthletes && filters.minAthletes > 1) {
        params.append('minAthletes', String(filters.minAthletes));
      }
      if (filters.boatClasses?.length) {
        params.append('boatClasses', filters.boatClasses.join(','));
      }
      if (filters.shellNames?.length) {
        params.append('shellNames', filters.shellNames.join(','));
      }
      if (filters.startDate) {
        params.append('startDate', filters.startDate);
      }
      if (filters.endDate) {
        params.append('endDate', filters.endDate);
      }
      if (filters.nameSearch) {
        params.append('nameSearch', filters.nameSearch);
      }
      if (filters.sortBy) {
        params.append('sortBy', filters.sortBy);
      }
      if (filters.sortDirection) {
        params.append('sortDirection', filters.sortDirection);
      }

      const response = await authenticatedFetch(`/api/v1/lineups/search?${params.toString()}`);
      const data = await response.json();
      if (!data.success) throw new Error(data.error?.message || 'Search failed');
      return data.data;
    },
    enabled: isAuthenticated && isInitialized && !!activeTeamId && enabled,
    staleTime: 2 * 60 * 1000, // 2 minutes
    placeholderData: keepPreviousData, // Keep previous results while fetching new
  });
}

/**
 * Build search filters from URL params (for deep linking)
 */
export function parseSearchFiltersFromUrl(searchParams: URLSearchParams): LineupSearchFilters {
  const athleteIds = searchParams.get('athleteIds');
  const minAthletes = searchParams.get('minAthletes');
  const boatClasses = searchParams.get('boatClasses');
  const shellNames = searchParams.get('shellNames');
  const startDate = searchParams.get('startDate');
  const endDate = searchParams.get('endDate');
  const nameSearch = searchParams.get('nameSearch');
  const sortBy = searchParams.get('sortBy') as LineupSearchFilters['sortBy'];
  const sortDirection = searchParams.get('sortDirection') as LineupSearchFilters['sortDirection'];

  return {
    athleteIds: athleteIds ? athleteIds.split(',') : undefined,
    minAthletes: minAthletes ? parseInt(minAthletes, 10) : undefined,
    boatClasses: boatClasses ? boatClasses.split(',') : undefined,
    shellNames: shellNames ? shellNames.split(',') : undefined,
    startDate: startDate || undefined,
    endDate: endDate || undefined,
    nameSearch: nameSearch || undefined,
    sortBy: sortBy || undefined,
    sortDirection: sortDirection || undefined,
  };
}

/**
 * Build URL params from search filters (for sharing/bookmarking)
 */
export function buildSearchParamsFromFilters(filters: LineupSearchFilters): URLSearchParams {
  const params = new URLSearchParams();

  if (filters.athleteIds?.length) {
    params.set('athleteIds', filters.athleteIds.join(','));
  }
  if (filters.minAthletes && filters.minAthletes > 1) {
    params.set('minAthletes', String(filters.minAthletes));
  }
  if (filters.boatClasses?.length) {
    params.set('boatClasses', filters.boatClasses.join(','));
  }
  if (filters.shellNames?.length) {
    params.set('shellNames', filters.shellNames.join(','));
  }
  if (filters.startDate) {
    params.set('startDate', filters.startDate);
  }
  if (filters.endDate) {
    params.set('endDate', filters.endDate);
  }
  if (filters.nameSearch) {
    params.set('nameSearch', filters.nameSearch);
  }
  if (filters.sortBy) {
    params.set('sortBy', filters.sortBy);
  }
  if (filters.sortDirection) {
    params.set('sortDirection', filters.sortDirection);
  }

  return params;
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/v2/hooks/useLineupSearch.ts` - should compile without errors.</verify>
  <done>Lineup search hook created with URL param helpers.</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit src/v2/hooks/useRiggingProfiles.ts` passes
- [ ] `npx tsc --noEmit src/v2/hooks/useLineupTemplates.ts` passes
- [ ] `npx tsc --noEmit src/v2/hooks/useEquipment.ts` passes
- [ ] `npx tsc --noEmit src/v2/hooks/useLineupSearch.ts` passes
- [ ] All hooks use query key factories
- [ ] Mutations invalidate related queries
</verification>

<success_criteria>
1. All hooks compile without TypeScript errors
2. Query key factories enable proper cache management
3. Mutations properly invalidate dependent queries
4. Hooks follow existing project patterns (useAthletes, useErgTests)
</success_criteria>

<output>
After completion, create `.planning/phases/18-lineup-boat-improvements/18-07-SUMMARY.md`
</output>
