---
phase: 18-lineup-boat-improvements
plan: 06
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - server/routes/lineups.js
  - server/services/lineupService.js
autonomous: true

must_haves:
  truths:
    - "Historical lineups can be searched by athletes, boat class, date range"
    - "Search supports 'at least N athletes' queries"
    - "Search results include metadata (athlete count, boat classes)"
  artifacts:
    - path: "server/routes/lineups.js"
      provides: "Extended lineup routes with search endpoint"
      contains: "/search"
    - path: "server/services/lineupService.js"
      provides: "Extended lineup service with search function"
      exports: ["searchLineups"]
  key_links:
    - from: "server/routes/lineups.js"
      to: "server/services/lineupService.js"
      via: "searchLineups call"
      pattern: "lineupService\\.searchLineups"
---

<objective>
Extend lineup API with historical search functionality.

Purpose: Enable coaches to find past lineups by criteria (athletes, boat class, date) for pattern analysis and reuse.
Output: Search endpoint on existing lineups API with multi-criteria filtering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-lineup-boat-improvements/18-RESEARCH.md
@server/routes/lineups.js
@server/services/lineupService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search function to lineup service</name>
  <files>server/services/lineupService.js</files>
  <action>
Add the following function to `server/services/lineupService.js`:

```javascript
/**
 * Search lineups with multi-criteria filtering - Phase 18 LINEUP-02
 *
 * Supports:
 * - Filter by athlete IDs (any match)
 * - Minimum N athletes requirement
 * - Filter by boat classes
 * - Filter by shell names
 * - Date range filtering
 * - Name search
 * - Sorting options
 */
export async function searchLineups(teamId, filters = {}) {
  const {
    athleteIds = [],
    minAthletes = 1,
    boatClasses = [],
    shellNames = [],
    startDate,
    endDate,
    nameSearch,
    sortBy = 'createdAt',
    sortDirection = 'desc',
    limit = 50,
    offset = 0,
  } = filters;

  // Build the where clause
  const where = { teamId };

  // Date range filter
  if (startDate || endDate) {
    where.createdAt = {};
    if (startDate) {
      where.createdAt.gte = new Date(startDate);
    }
    if (endDate) {
      where.createdAt.lte = new Date(endDate);
    }
  }

  // Name search
  if (nameSearch) {
    where.name = {
      contains: nameSearch,
      mode: 'insensitive',
    };
  }

  // For athlete filtering, we need to handle "at least N athletes" logic
  // This is complex in Prisma, so we'll use a two-step approach:
  // 1. Filter lineups that have ANY of the specified athletes
  // 2. Post-process to check minimum count

  if (athleteIds.length > 0) {
    where.assignments = {
      some: {
        athleteId: { in: athleteIds },
      },
    };
  }

  // Boat class filter
  if (boatClasses.length > 0) {
    where.assignments = {
      ...where.assignments,
      some: {
        ...where.assignments?.some,
        boatClass: { in: boatClasses },
      },
    };
  }

  // Shell name filter
  if (shellNames.length > 0) {
    where.assignments = {
      ...where.assignments,
      some: {
        ...where.assignments?.some,
        shellName: { in: shellNames },
      },
    };
  }

  // Determine sort order
  const orderBy = {};
  if (sortBy === 'date' || sortBy === 'createdAt') {
    orderBy.createdAt = sortDirection;
  } else if (sortBy === 'name') {
    orderBy.name = sortDirection;
  } else if (sortBy === 'updatedAt') {
    orderBy.updatedAt = sortDirection;
  } else {
    orderBy.createdAt = 'desc';
  }

  // Fetch lineups with assignments
  const lineups = await prisma.lineup.findMany({
    where,
    include: {
      assignments: {
        select: {
          athleteId: true,
          boatClass: true,
          shellName: true,
        },
      },
    },
    orderBy,
    take: limit + offset, // Fetch extra for post-filtering
  });

  // Post-process to check minimum athlete count and build metadata
  let results = lineups.map((lineup) => {
    const athleteCount = lineup.assignments.length;
    const boatClassSet = new Set(lineup.assignments.map((a) => a.boatClass));
    const shellNameSet = new Set(
      lineup.assignments.filter((a) => a.shellName).map((a) => a.shellName)
    );

    // Count matched athletes if filtering
    let matchedAthleteCount = 0;
    if (athleteIds.length > 0) {
      const lineupAthleteIds = new Set(lineup.assignments.map((a) => a.athleteId));
      matchedAthleteCount = athleteIds.filter((id) => lineupAthleteIds.has(id)).length;
    }

    return {
      id: lineup.id,
      name: lineup.name,
      notes: lineup.notes,
      createdAt: lineup.createdAt.toISOString(),
      updatedAt: lineup.updatedAt.toISOString(),
      athleteCount,
      boatClasses: Array.from(boatClassSet),
      shellNames: Array.from(shellNameSet),
      matchedAthleteCount: athleteIds.length > 0 ? matchedAthleteCount : undefined,
    };
  });

  // Filter by minimum athlete count if specified
  if (athleteIds.length > 0 && minAthletes > 1) {
    results = results.filter((r) => r.matchedAthleteCount >= minAthletes);
  }

  // Apply offset and limit after filtering
  const total = results.length;
  results = results.slice(offset, offset + limit);

  return {
    lineups: results,
    total,
    limit,
    offset,
  };
}
```

Add to the imports at the top of the file if not already present:
```javascript
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
```
  </action>
  <verify>Run `node -c server/services/lineupService.js` - should parse without syntax errors.</verify>
  <done>searchLineups function added to lineup service.</done>
</task>

<task type="auto">
  <name>Task 2: Add search endpoint to lineup routes</name>
  <files>server/routes/lineups.js</files>
  <action>
Add the search endpoint to `server/routes/lineups.js` before the :id routes (to avoid route conflicts):

```javascript
/**
 * GET /api/v1/lineups/search
 * Search historical lineups with multi-criteria filtering
 *
 * Query params:
 * - athleteIds: comma-separated athlete IDs (any match)
 * - minAthletes: minimum number of specified athletes (default: 1)
 * - boatClasses: comma-separated boat classes
 * - shellNames: comma-separated shell names
 * - startDate: ISO date for range start
 * - endDate: ISO date for range end
 * - nameSearch: partial name match
 * - sortBy: 'date' | 'name' | 'createdAt' | 'updatedAt' (default: createdAt)
 * - sortDirection: 'asc' | 'desc' (default: desc)
 * - limit: max results (default: 50)
 * - offset: pagination offset (default: 0)
 */
router.get(
  '/search',
  authenticateToken,
  requireTeam,
  [
    query('athleteIds').optional().isString(),
    query('minAthletes').optional().isInt({ min: 1 }),
    query('boatClasses').optional().isString(),
    query('shellNames').optional().isString(),
    query('startDate').optional().isISO8601(),
    query('endDate').optional().isISO8601(),
    query('nameSearch').optional().isString(),
    query('sortBy').optional().isIn(['date', 'name', 'createdAt', 'updatedAt']),
    query('sortDirection').optional().isIn(['asc', 'desc']),
    query('limit').optional().isInt({ min: 1, max: 200 }),
    query('offset').optional().isInt({ min: 0 }),
  ],
  validateRequest,
  async (req, res) => {
    try {
      const filters = {
        athleteIds: req.query.athleteIds
          ? req.query.athleteIds.split(',').filter(Boolean)
          : [],
        minAthletes: req.query.minAthletes
          ? parseInt(req.query.minAthletes, 10)
          : 1,
        boatClasses: req.query.boatClasses
          ? req.query.boatClasses.split(',').filter(Boolean)
          : [],
        shellNames: req.query.shellNames
          ? req.query.shellNames.split(',').filter(Boolean)
          : [],
        startDate: req.query.startDate || null,
        endDate: req.query.endDate || null,
        nameSearch: req.query.nameSearch || null,
        sortBy: req.query.sortBy || 'createdAt',
        sortDirection: req.query.sortDirection || 'desc',
        limit: req.query.limit ? parseInt(req.query.limit, 10) : 50,
        offset: req.query.offset ? parseInt(req.query.offset, 10) : 0,
      };

      const result = await lineupService.searchLineups(
        req.user.activeTeamId,
        filters
      );

      res.json({ success: true, data: result });
    } catch (error) {
      logger.error('Error searching lineups:', error);
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);
```

Make sure to:
1. Import the searchLineups function from lineupService if using named exports, or ensure it's exported from the default export
2. Place this route BEFORE the `/:id` routes to avoid route conflicts (Express matches routes in order)
3. Add `query` to the express-validator imports if not already present
  </action>
  <verify>Run `node -c server/routes/lineups.js` - should parse without syntax errors.</verify>
  <done>Search endpoint added to lineup routes.</done>
</task>

<task type="auto">
  <name>Task 3: Test search endpoint</name>
  <files>server/routes/lineups.js</files>
  <action>
Verify the search endpoint is working:

1. Start the server: `npm run server`
2. Test that the endpoint exists and requires auth:
   - `curl -X GET "http://localhost:8000/api/v1/lineups/search"` should return 401

3. Verify route ordering doesn't conflict with existing routes by checking the route file structure:
   - The `/search` route must come BEFORE any `/:id` pattern routes
   - If there's already a `/search` route or similar, modify it rather than adding a new one

Note: Full integration testing requires authentication. The endpoint structure is:
- GET /api/v1/lineups/search?athleteIds=id1,id2&minAthletes=2&boatClasses=8+,4+
  </action>
  <verify>curl returns 401 for /api/v1/lineups/search (confirms route is mounted and requires auth).</verify>
  <done>Search endpoint tested and route ordering verified.</done>
</task>

</tasks>

<verification>
- [ ] `node -c server/services/lineupService.js` passes
- [ ] `node -c server/routes/lineups.js` passes
- [ ] Server starts without errors
- [ ] GET /api/v1/lineups/search returns 401 (auth required)
- [ ] Route doesn't conflict with existing /api/v1/lineups/:id routes
</verification>

<success_criteria>
1. Search function handles all filter types
2. "At least N athletes" filtering works correctly
3. Pagination with limit/offset works
4. Results include metadata (athlete count, boat classes)
5. Route is placed before :id routes to avoid conflicts
</success_criteria>

<output>
After completion, create `.planning/phases/18-lineup-boat-improvements/18-06-SUMMARY.md`
</output>
