---
phase: 18-lineup-boat-improvements
plan: 05
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - server/routes/equipment.js
  - server/services/equipmentService.js
  - server/routes/lineups.js
  - server/index.js
autonomous: true

must_haves:
  truths:
    - "Equipment assignments can be created and queried via API"
    - "Conflict detection returns double-booking warnings for shells/oars"
    - "Equipment availability endpoint returns status with conflicts"
  artifacts:
    - path: "server/routes/equipment.js"
      provides: "REST API endpoints for equipment assignment and conflicts"
      exports: ["router"]
    - path: "server/services/equipmentService.js"
      provides: "Business logic for equipment assignment and conflict detection"
      exports: ["assignEquipment", "checkConflicts", "getEquipmentAvailability"]
  key_links:
    - from: "server/routes/equipment.js"
      to: "server/services/equipmentService.js"
      via: "Service function calls"
      pattern: "equipmentService\\."
---

<objective>
Create backend API for equipment assignment and conflict detection.

Purpose: Enable coaches to track which shells and oar sets are assigned to lineups/sessions, with warnings for double-booking.
Output: REST API endpoints for equipment assignment CRUD and availability checking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-lineup-boat-improvements/18-RESEARCH.md
@prisma/schema.prisma
@server/routes/shells.js
@server/services/shellService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create equipment service</name>
  <files>server/services/equipmentService.js</files>
  <action>
Create `server/services/equipmentService.js` with:

```javascript
/**
 * Equipment Service - Phase 18 BOAT-03, BOAT-04
 *
 * Manages equipment assignments and conflict detection with team isolation.
 */

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Create an equipment assignment
 */
export async function createAssignment(teamId, data) {
  const assignment = await prisma.equipmentAssignment.create({
    data: {
      teamId,
      lineupId: data.lineupId || null,
      sessionId: data.sessionId || null,
      shellId: data.shellId || null,
      oarSetId: data.oarSetId || null,
      assignedDate: new Date(data.assignedDate),
      notes: data.notes || null,
    },
    include: {
      shell: { select: { id: true, name: true, boatClass: true } },
      oarSet: { select: { id: true, name: true, type: true } },
      lineup: { select: { id: true, name: true } },
    },
  });

  return formatAssignment(assignment);
}

/**
 * Get assignments for a team on a specific date
 */
export async function getAssignments(teamId, date) {
  const targetDate = new Date(date);
  const startOfDay = new Date(targetDate.setHours(0, 0, 0, 0));
  const endOfDay = new Date(targetDate.setHours(23, 59, 59, 999));

  const assignments = await prisma.equipmentAssignment.findMany({
    where: {
      teamId,
      assignedDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
    },
    include: {
      shell: { select: { id: true, name: true, boatClass: true, status: true } },
      oarSet: { select: { id: true, name: true, type: true, status: true } },
      lineup: { select: { id: true, name: true } },
    },
    orderBy: { createdAt: 'desc' },
  });

  return assignments.map(formatAssignment);
}

/**
 * Get assignments for a specific lineup
 */
export async function getLineupAssignments(lineupId, teamId) {
  const assignments = await prisma.equipmentAssignment.findMany({
    where: { lineupId, teamId },
    include: {
      shell: { select: { id: true, name: true, boatClass: true, status: true } },
      oarSet: { select: { id: true, name: true, type: true, status: true } },
    },
    orderBy: { createdAt: 'desc' },
  });

  return assignments.map(formatAssignment);
}

/**
 * Delete an assignment
 */
export async function deleteAssignment(assignmentId, teamId) {
  const assignment = await prisma.equipmentAssignment.findFirst({
    where: { id: assignmentId, teamId },
  });

  if (!assignment) {
    throw new Error('Assignment not found');
  }

  await prisma.equipmentAssignment.delete({
    where: { id: assignmentId },
  });

  return { success: true };
}

/**
 * Check for equipment conflicts on a given date
 */
export async function checkConflicts(teamId, date, shellIds = [], oarSetIds = [], excludeLineupId = null) {
  const targetDate = new Date(date);
  const startOfDay = new Date(targetDate.setHours(0, 0, 0, 0));
  const endOfDay = new Date(targetDate.setHours(23, 59, 59, 999));

  const conflicts = [];

  // Check shell conflicts
  if (shellIds.length > 0) {
    const shellAssignments = await prisma.equipmentAssignment.findMany({
      where: {
        teamId,
        shellId: { in: shellIds },
        assignedDate: {
          gte: startOfDay,
          lte: endOfDay,
        },
        ...(excludeLineupId && { lineupId: { not: excludeLineupId } }),
      },
      include: {
        shell: { select: { id: true, name: true } },
        lineup: { select: { id: true, name: true } },
      },
    });

    for (const assignment of shellAssignments) {
      conflicts.push({
        type: 'double_booking',
        equipmentId: assignment.shellId,
        equipmentName: assignment.shell.name,
        equipmentType: 'shell',
        conflictingId: assignment.lineupId || assignment.sessionId,
        conflictingName: assignment.lineup?.name || 'Session',
        conflictDate: date,
        message: `${assignment.shell.name} is already assigned to "${assignment.lineup?.name || 'a session'}"`,
      });
    }
  }

  // Check oar set conflicts
  if (oarSetIds.length > 0) {
    const oarAssignments = await prisma.equipmentAssignment.findMany({
      where: {
        teamId,
        oarSetId: { in: oarSetIds },
        assignedDate: {
          gte: startOfDay,
          lte: endOfDay,
        },
        ...(excludeLineupId && { lineupId: { not: excludeLineupId } }),
      },
      include: {
        oarSet: { select: { id: true, name: true } },
        lineup: { select: { id: true, name: true } },
      },
    });

    for (const assignment of oarAssignments) {
      conflicts.push({
        type: 'double_booking',
        equipmentId: assignment.oarSetId,
        equipmentName: assignment.oarSet.name,
        equipmentType: 'oarSet',
        conflictingId: assignment.lineupId || assignment.sessionId,
        conflictingName: assignment.lineup?.name || 'Session',
        conflictDate: date,
        message: `${assignment.oarSet.name} is already assigned to "${assignment.lineup?.name || 'a session'}"`,
      });
    }
  }

  // Check for maintenance status
  if (shellIds.length > 0) {
    const maintenanceShells = await prisma.shell.findMany({
      where: {
        id: { in: shellIds },
        teamId,
        status: { in: ['MAINTENANCE', 'RETIRED'] },
      },
    });

    for (const shell of maintenanceShells) {
      conflicts.push({
        type: shell.status === 'MAINTENANCE' ? 'maintenance' : 'unavailable',
        equipmentId: shell.id,
        equipmentName: shell.name,
        equipmentType: 'shell',
        conflictingId: null,
        conflictingName: null,
        conflictDate: date,
        message: `${shell.name} is ${shell.status.toLowerCase()}`,
      });
    }
  }

  return conflicts;
}

/**
 * Get equipment availability for a date (all shells and oars with status)
 */
export async function getEquipmentAvailability(teamId, date, excludeLineupId = null) {
  const targetDate = new Date(date);
  const startOfDay = new Date(targetDate.setHours(0, 0, 0, 0));
  const endOfDay = new Date(targetDate.setHours(23, 59, 59, 999));

  // Get all shells
  const shells = await prisma.shell.findMany({
    where: { teamId },
    include: {
      riggingProfile: { select: { id: true } },
    },
    orderBy: { name: 'asc' },
  });

  // Get all oar sets
  const oarSets = await prisma.oarSet.findMany({
    where: { teamId },
    orderBy: { name: 'asc' },
  });

  // Get assignments for the date
  const assignments = await prisma.equipmentAssignment.findMany({
    where: {
      teamId,
      assignedDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      ...(excludeLineupId && { lineupId: { not: excludeLineupId } }),
    },
    include: {
      lineup: { select: { id: true, name: true } },
    },
  });

  // Build conflict maps
  const shellConflicts = new Map();
  const oarConflicts = new Map();

  for (const assignment of assignments) {
    if (assignment.shellId) {
      const existing = shellConflicts.get(assignment.shellId);
      if (!existing) {
        shellConflicts.set(assignment.shellId, {
          type: 'double_booking',
          conflictingId: assignment.lineupId || assignment.sessionId,
          conflictingName: assignment.lineup?.name || 'Session',
        });
      }
    }
    if (assignment.oarSetId) {
      const existing = oarConflicts.get(assignment.oarSetId);
      if (!existing) {
        oarConflicts.set(assignment.oarSetId, {
          type: 'double_booking',
          conflictingId: assignment.lineupId || assignment.sessionId,
          conflictingName: assignment.lineup?.name || 'Session',
        });
      }
    }
  }

  // Format shells with status
  const shellsWithStatus = shells.map((shell) => {
    const conflict = shellConflicts.get(shell.id);
    const isUnavailable = ['MAINTENANCE', 'RETIRED'].includes(shell.status);

    return {
      id: shell.id,
      name: shell.name,
      boatClass: shell.boatClass,
      type: shell.type,
      weightClass: shell.weightClass,
      rigging: shell.rigging,
      status: shell.status,
      notes: shell.notes,
      isAssignedForDate: !!conflict,
      hasRiggingProfile: !!shell.riggingProfile,
      conflict: conflict
        ? {
            type: conflict.type,
            equipmentId: shell.id,
            equipmentName: shell.name,
            equipmentType: 'shell',
            conflictingId: conflict.conflictingId,
            conflictingName: conflict.conflictingName,
            conflictDate: date,
            message: `${shell.name} is already assigned to "${conflict.conflictingName}"`,
          }
        : isUnavailable
        ? {
            type: shell.status === 'MAINTENANCE' ? 'maintenance' : 'unavailable',
            equipmentId: shell.id,
            equipmentName: shell.name,
            equipmentType: 'shell',
            conflictingId: null,
            conflictingName: null,
            conflictDate: date,
            message: `${shell.name} is ${shell.status.toLowerCase()}`,
          }
        : null,
    };
  });

  // Format oar sets with status
  const oarSetsWithStatus = oarSets.map((oarSet) => {
    const conflict = oarConflicts.get(oarSet.id);
    const isUnavailable = ['MAINTENANCE', 'RETIRED'].includes(oarSet.status);

    return {
      id: oarSet.id,
      name: oarSet.name,
      type: oarSet.type,
      count: oarSet.count,
      status: oarSet.status,
      notes: oarSet.notes,
      isAssignedForDate: !!conflict,
      conflict: conflict
        ? {
            type: conflict.type,
            equipmentId: oarSet.id,
            equipmentName: oarSet.name,
            equipmentType: 'oarSet',
            conflictingId: conflict.conflictingId,
            conflictingName: conflict.conflictingName,
            conflictDate: date,
            message: `${oarSet.name} is already assigned to "${conflict.conflictingName}"`,
          }
        : isUnavailable
        ? {
            type: oarSet.status === 'MAINTENANCE' ? 'maintenance' : 'unavailable',
            equipmentId: oarSet.id,
            equipmentName: oarSet.name,
            equipmentType: 'oarSet',
            conflictingId: null,
            conflictingName: null,
            conflictDate: date,
            message: `${oarSet.name} is ${oarSet.status.toLowerCase()}`,
          }
        : null,
    };
  });

  return {
    date,
    shells: shellsWithStatus,
    oarSets: oarSetsWithStatus,
    conflictCount:
      shellsWithStatus.filter((s) => s.conflict).length +
      oarSetsWithStatus.filter((o) => o.conflict).length,
  };
}

/**
 * Format assignment for API response
 */
function formatAssignment(assignment) {
  return {
    id: assignment.id,
    teamId: assignment.teamId,
    lineupId: assignment.lineupId,
    sessionId: assignment.sessionId,
    shellId: assignment.shellId,
    oarSetId: assignment.oarSetId,
    assignedDate: assignment.assignedDate.toISOString().split('T')[0],
    notes: assignment.notes,
    createdAt: assignment.createdAt.toISOString(),
    shellName: assignment.shell?.name || null,
    oarSetName: assignment.oarSet?.name || null,
    lineupName: assignment.lineup?.name || null,
  };
}
```
  </action>
  <verify>Run `node -c server/services/equipmentService.js` - should parse without syntax errors.</verify>
  <done>Equipment service created with assignment CRUD and conflict detection.</done>
</task>

<task type="auto">
  <name>Task 2: Create equipment routes</name>
  <files>server/routes/equipment.js</files>
  <action>
Create `server/routes/equipment.js` with:

```javascript
/**
 * Equipment Assignment Routes - Phase 18 BOAT-03, BOAT-04
 *
 * Endpoints:
 * GET    /api/v1/equipment/availability       - Get equipment availability for a date
 * GET    /api/v1/equipment/assignments        - Get assignments for a date
 * GET    /api/v1/equipment/assignments/lineup/:lineupId - Get assignments for a lineup
 * POST   /api/v1/equipment/assignments        - Create assignment
 * DELETE /api/v1/equipment/assignments/:id    - Delete assignment
 * POST   /api/v1/equipment/check-conflicts    - Check for conflicts
 */

import express from 'express';
import { param, body, query } from 'express-validator';
import { authenticateToken, requireTeam } from '../middleware/auth.js';
import { validateRequest } from '../middleware/validation.js';
import * as equipmentService from '../services/equipmentService.js';
import { logger } from '../utils/logger.js';

const router = express.Router();

/**
 * GET /api/v1/equipment/availability
 * Get all equipment with availability status for a date
 */
router.get(
  '/availability',
  authenticateToken,
  requireTeam,
  [
    query('date').isISO8601().withMessage('date must be a valid ISO date'),
    query('excludeLineupId').optional().isString(),
  ],
  validateRequest,
  async (req, res) => {
    try {
      const availability = await equipmentService.getEquipmentAvailability(
        req.user.activeTeamId,
        req.query.date,
        req.query.excludeLineupId || null
      );
      res.json({ success: true, data: availability });
    } catch (error) {
      logger.error('Error fetching equipment availability:', error);
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * GET /api/v1/equipment/assignments
 * Get assignments for a specific date
 */
router.get(
  '/assignments',
  authenticateToken,
  requireTeam,
  [query('date').isISO8601().withMessage('date must be a valid ISO date')],
  validateRequest,
  async (req, res) => {
    try {
      const assignments = await equipmentService.getAssignments(
        req.user.activeTeamId,
        req.query.date
      );
      res.json({ success: true, data: { assignments } });
    } catch (error) {
      logger.error('Error fetching assignments:', error);
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * GET /api/v1/equipment/assignments/lineup/:lineupId
 * Get assignments for a specific lineup
 */
router.get(
  '/assignments/lineup/:lineupId',
  authenticateToken,
  requireTeam,
  [param('lineupId').isString().notEmpty()],
  validateRequest,
  async (req, res) => {
    try {
      const assignments = await equipmentService.getLineupAssignments(
        req.params.lineupId,
        req.user.activeTeamId
      );
      res.json({ success: true, data: { assignments } });
    } catch (error) {
      logger.error('Error fetching lineup assignments:', error);
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * POST /api/v1/equipment/assignments
 * Create an equipment assignment
 */
router.post(
  '/assignments',
  authenticateToken,
  requireTeam,
  [
    body('lineupId').optional().isString(),
    body('sessionId').optional().isString(),
    body('shellId').optional().isString(),
    body('oarSetId').optional().isString(),
    body('assignedDate').isISO8601().withMessage('assignedDate must be a valid ISO date'),
    body('notes').optional().isString(),
  ],
  validateRequest,
  async (req, res) => {
    try {
      // Validate that at least one equipment type is specified
      if (!req.body.shellId && !req.body.oarSetId) {
        return res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_INPUT',
            message: 'At least one of shellId or oarSetId is required',
          },
        });
      }

      const assignment = await equipmentService.createAssignment(
        req.user.activeTeamId,
        req.body
      );
      res.status(201).json({ success: true, data: { assignment } });
    } catch (error) {
      logger.error('Error creating assignment:', error);
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * DELETE /api/v1/equipment/assignments/:id
 * Delete an equipment assignment
 */
router.delete(
  '/assignments/:id',
  authenticateToken,
  requireTeam,
  [param('id').isString().notEmpty()],
  validateRequest,
  async (req, res) => {
    try {
      await equipmentService.deleteAssignment(
        req.params.id,
        req.user.activeTeamId
      );
      res.json({ success: true, data: { message: 'Assignment deleted' } });
    } catch (error) {
      logger.error('Error deleting assignment:', error);
      if (error.message === 'Assignment not found') {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Assignment not found' },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * POST /api/v1/equipment/check-conflicts
 * Check for equipment conflicts
 */
router.post(
  '/check-conflicts',
  authenticateToken,
  requireTeam,
  [
    body('date').isISO8601().withMessage('date must be a valid ISO date'),
    body('shellIds').optional().isArray(),
    body('oarSetIds').optional().isArray(),
    body('excludeLineupId').optional().isString(),
  ],
  validateRequest,
  async (req, res) => {
    try {
      const conflicts = await equipmentService.checkConflicts(
        req.user.activeTeamId,
        req.body.date,
        req.body.shellIds || [],
        req.body.oarSetIds || [],
        req.body.excludeLineupId || null
      );
      res.json({
        success: true,
        data: {
          conflicts,
          hasConflicts: conflicts.length > 0,
        },
      });
    } catch (error) {
      logger.error('Error checking conflicts:', error);
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

export default router;
```
  </action>
  <verify>Run `node -c server/routes/equipment.js` - should parse without syntax errors.</verify>
  <done>Equipment routes created with availability, assignment, and conflict endpoints.</done>
</task>

<task type="auto">
  <name>Task 3: Mount equipment routes</name>
  <files>server/index.js</files>
  <action>
Add equipment routes to server/index.js:

1. Import the routes at the top with other route imports:
```javascript
import equipmentRoutes from './routes/equipment.js';
```

2. Mount the routes with other API routes:
```javascript
app.use('/api/v1/equipment', apiLimiter, equipmentRoutes);
```
  </action>
  <verify>Server starts without errors. `curl -X GET "http://localhost:8000/api/v1/equipment/availability?date=2026-01-27"` returns 401.</verify>
  <done>Equipment routes mounted at /api/v1/equipment.</done>
</task>

</tasks>

<verification>
- [ ] `node -c server/services/equipmentService.js` passes
- [ ] `node -c server/routes/equipment.js` passes
- [ ] Server starts without errors
- [ ] GET /api/v1/equipment/availability returns 401 (auth required)
- [ ] POST /api/v1/equipment/check-conflicts returns 401 (auth required)
</verification>

<success_criteria>
1. Equipment assignments can be created with shell/oar set links
2. Conflict detection identifies double-bookings correctly
3. Availability endpoint returns all equipment with conflict status
4. Maintenance/retired equipment flagged as unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/18-lineup-boat-improvements/18-05-SUMMARY.md`
</output>
