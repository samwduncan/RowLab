---
phase: 18-lineup-boat-improvements
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - server/routes/rigging.js
  - server/services/riggingService.js
  - server/index.js
autonomous: true

must_haves:
  truths:
    - "Rigging profiles can be created, read, updated, deleted via API"
    - "Default rigging is returned for shells without custom profiles"
    - "API requires authentication and team isolation"
  artifacts:
    - path: "server/routes/rigging.js"
      provides: "REST API endpoints for rigging CRUD"
      exports: ["router"]
    - path: "server/services/riggingService.js"
      provides: "Business logic for rigging operations"
      exports: ["getRiggingProfile", "upsertRiggingProfile", "deleteRiggingProfile"]
  key_links:
    - from: "server/routes/rigging.js"
      to: "server/services/riggingService.js"
      via: "Service function calls"
      pattern: "riggingService\\."
    - from: "server/index.js"
      to: "server/routes/rigging.js"
      via: "Route mounting"
      pattern: "app\\.use.*rigging"
---

<objective>
Create backend API for rigging profile management.

Purpose: Enable coaches to store and retrieve rigging settings per shell, with defaults for new shells.
Output: REST API endpoints for rigging CRUD operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-lineup-boat-improvements/18-RESEARCH.md
@prisma/schema.prisma
@server/routes/shells.js
@server/middleware/auth.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rigging service</name>
  <files>server/services/riggingService.js</files>
  <action>
Create `server/services/riggingService.js` with:

```javascript
/**
 * Rigging Profile Service - Phase 18 BOAT-02
 *
 * Manages rigging settings per shell with team isolation.
 */

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Default rigging values by boat class (from World Rowing / Concept2)
 */
const DEFAULT_RIGGING = {
  '8+': {
    spread: 85,
    catchAngle: -58,
    finishAngle: 33,
    oarLength: 372,
    inboard: 114,
    pitch: 4,
    gateHeight: 170,
  },
  '4+': {
    spread: 86,
    catchAngle: -58,
    finishAngle: 33,
    oarLength: 372,
    inboard: 114,
    pitch: 4,
    gateHeight: 170,
  },
  '4-': {
    spread: 86,
    catchAngle: -58,
    finishAngle: 33,
    oarLength: 372,
    inboard: 114,
    pitch: 4,
    gateHeight: 170,
  },
  '4x': {
    span: 158,
    catchAngle: -60,
    finishAngle: 35,
    oarLength: 284,
    inboard: 88,
    pitch: 4,
    gateHeight: 160,
  },
  '2x': {
    span: 160,
    catchAngle: -60,
    finishAngle: 35,
    oarLength: 287,
    inboard: 88,
    pitch: 4,
    gateHeight: 160,
  },
  '2-': {
    spread: 86,
    catchAngle: -58,
    finishAngle: 33,
    oarLength: 372,
    inboard: 114,
    pitch: 4,
    gateHeight: 170,
  },
  '1x': {
    span: 160,
    catchAngle: -60,
    finishAngle: 35,
    oarLength: 289,
    inboard: 88,
    pitch: 4,
    gateHeight: 160,
  },
};

/**
 * Get default rigging for a boat class
 */
export function getDefaultRigging(boatClass) {
  return DEFAULT_RIGGING[boatClass] || DEFAULT_RIGGING['8+'];
}

/**
 * Get rigging profile for a shell
 * Returns custom profile if exists, otherwise default based on boat class
 */
export async function getRiggingProfile(shellId, teamId) {
  // First get the shell to know its boat class
  const shell = await prisma.shell.findFirst({
    where: { id: shellId, teamId },
  });

  if (!shell) {
    throw new Error('Shell not found');
  }

  // Check for custom rigging profile
  const profile = await prisma.riggingProfile.findUnique({
    where: { shellId },
  });

  if (profile) {
    return {
      ...profile,
      isCustom: true,
      shellName: shell.name,
      boatClass: shell.boatClass,
    };
  }

  // Return default rigging
  return {
    id: null,
    shellId,
    teamId,
    defaults: getDefaultRigging(shell.boatClass),
    perSeat: null,
    notes: null,
    isCustom: false,
    shellName: shell.name,
    boatClass: shell.boatClass,
  };
}

/**
 * Get all rigging profiles for a team (with shells that have custom rigging)
 */
export async function getTeamRiggingProfiles(teamId) {
  const profiles = await prisma.riggingProfile.findMany({
    where: { teamId },
    include: {
      shell: {
        select: {
          id: true,
          name: true,
          boatClass: true,
          status: true,
        },
      },
    },
    orderBy: { updatedAt: 'desc' },
  });

  return profiles.map((p) => ({
    ...p,
    shellName: p.shell.name,
    boatClass: p.shell.boatClass,
    shellStatus: p.shell.status,
  }));
}

/**
 * Create or update rigging profile for a shell
 */
export async function upsertRiggingProfile(shellId, teamId, data) {
  // Verify shell belongs to team
  const shell = await prisma.shell.findFirst({
    where: { id: shellId, teamId },
  });

  if (!shell) {
    throw new Error('Shell not found');
  }

  const profile = await prisma.riggingProfile.upsert({
    where: { shellId },
    create: {
      shellId,
      teamId,
      defaults: data.defaults,
      perSeat: data.perSeat || null,
      notes: data.notes || null,
    },
    update: {
      defaults: data.defaults,
      perSeat: data.perSeat || null,
      notes: data.notes || null,
      updatedAt: new Date(),
    },
  });

  return {
    ...profile,
    isCustom: true,
    shellName: shell.name,
    boatClass: shell.boatClass,
  };
}

/**
 * Delete rigging profile (reverts to defaults)
 */
export async function deleteRiggingProfile(shellId, teamId) {
  // Verify shell belongs to team
  const shell = await prisma.shell.findFirst({
    where: { id: shellId, teamId },
  });

  if (!shell) {
    throw new Error('Shell not found');
  }

  const profile = await prisma.riggingProfile.findUnique({
    where: { shellId },
  });

  if (!profile) {
    throw new Error('Rigging profile not found');
  }

  await prisma.riggingProfile.delete({
    where: { shellId },
  });

  return { success: true };
}

/**
 * Get all default rigging values (for reference)
 */
export function getAllDefaultRigging() {
  return DEFAULT_RIGGING;
}
```
  </action>
  <verify>Run `node -c server/services/riggingService.js` - should parse without syntax errors.</verify>
  <done>Rigging service created with getRiggingProfile, upsertRiggingProfile, deleteRiggingProfile functions.</done>
</task>

<task type="auto">
  <name>Task 2: Create rigging routes</name>
  <files>server/routes/rigging.js</files>
  <action>
Create `server/routes/rigging.js` with:

```javascript
/**
 * Rigging Profile Routes - Phase 18 BOAT-02
 *
 * Endpoints:
 * GET    /api/v1/rigging/defaults           - Get all default rigging values
 * GET    /api/v1/rigging/shell/:shellId     - Get rigging for a shell
 * GET    /api/v1/rigging                    - Get all team rigging profiles
 * PUT    /api/v1/rigging/shell/:shellId     - Create/update rigging for a shell
 * DELETE /api/v1/rigging/shell/:shellId     - Delete custom rigging (revert to default)
 */

import express from 'express';
import { param, body } from 'express-validator';
import { authenticateToken, requireTeam } from '../middleware/auth.js';
import { validateRequest } from '../middleware/validation.js';
import * as riggingService from '../services/riggingService.js';
import { logger } from '../utils/logger.js';

const router = express.Router();

/**
 * GET /api/v1/rigging/defaults
 * Get all default rigging values by boat class
 */
router.get('/defaults', authenticateToken, requireTeam, async (req, res) => {
  try {
    const defaults = riggingService.getAllDefaultRigging();
    res.json({ success: true, data: { defaults } });
  } catch (error) {
    logger.error('Error fetching default rigging:', error);
    res.status(500).json({
      success: false,
      error: { code: 'SERVER_ERROR', message: error.message },
    });
  }
});

/**
 * GET /api/v1/rigging
 * Get all rigging profiles for the team
 */
router.get('/', authenticateToken, requireTeam, async (req, res) => {
  try {
    const profiles = await riggingService.getTeamRiggingProfiles(
      req.user.activeTeamId
    );
    res.json({ success: true, data: { profiles } });
  } catch (error) {
    logger.error('Error fetching team rigging profiles:', error);
    res.status(500).json({
      success: false,
      error: { code: 'SERVER_ERROR', message: error.message },
    });
  }
});

/**
 * GET /api/v1/rigging/shell/:shellId
 * Get rigging profile for a specific shell
 */
router.get(
  '/shell/:shellId',
  authenticateToken,
  requireTeam,
  [param('shellId').isString().notEmpty()],
  validateRequest,
  async (req, res) => {
    try {
      const profile = await riggingService.getRiggingProfile(
        req.params.shellId,
        req.user.activeTeamId
      );
      res.json({ success: true, data: { profile } });
    } catch (error) {
      logger.error('Error fetching rigging profile:', error);
      if (error.message === 'Shell not found') {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Shell not found' },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * PUT /api/v1/rigging/shell/:shellId
 * Create or update rigging profile for a shell
 */
router.put(
  '/shell/:shellId',
  authenticateToken,
  requireTeam,
  [
    param('shellId').isString().notEmpty(),
    body('defaults').isObject().withMessage('defaults must be an object'),
    body('defaults.spread')
      .optional()
      .isNumeric()
      .withMessage('spread must be a number'),
    body('defaults.span')
      .optional()
      .isNumeric()
      .withMessage('span must be a number'),
    body('defaults.catchAngle')
      .optional()
      .isNumeric()
      .withMessage('catchAngle must be a number'),
    body('defaults.finishAngle')
      .optional()
      .isNumeric()
      .withMessage('finishAngle must be a number'),
    body('defaults.oarLength')
      .optional()
      .isNumeric()
      .withMessage('oarLength must be a number'),
    body('defaults.inboard')
      .optional()
      .isNumeric()
      .withMessage('inboard must be a number'),
    body('defaults.pitch')
      .optional()
      .isNumeric()
      .withMessage('pitch must be a number'),
    body('defaults.gateHeight')
      .optional()
      .isNumeric()
      .withMessage('gateHeight must be a number'),
    body('perSeat').optional().isObject(),
    body('notes').optional().isString(),
  ],
  validateRequest,
  async (req, res) => {
    try {
      const profile = await riggingService.upsertRiggingProfile(
        req.params.shellId,
        req.user.activeTeamId,
        req.body
      );
      res.json({ success: true, data: { profile } });
    } catch (error) {
      logger.error('Error saving rigging profile:', error);
      if (error.message === 'Shell not found') {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Shell not found' },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * DELETE /api/v1/rigging/shell/:shellId
 * Delete custom rigging profile (reverts shell to default)
 */
router.delete(
  '/shell/:shellId',
  authenticateToken,
  requireTeam,
  [param('shellId').isString().notEmpty()],
  validateRequest,
  async (req, res) => {
    try {
      await riggingService.deleteRiggingProfile(
        req.params.shellId,
        req.user.activeTeamId
      );
      res.json({ success: true, data: { message: 'Rigging profile deleted' } });
    } catch (error) {
      logger.error('Error deleting rigging profile:', error);
      if (
        error.message === 'Shell not found' ||
        error.message === 'Rigging profile not found'
      ) {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: error.message },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

export default router;
```
  </action>
  <verify>Run `node -c server/routes/rigging.js` - should parse without syntax errors.</verify>
  <done>Rigging routes created with GET, PUT, DELETE endpoints.</done>
</task>

<task type="auto">
  <name>Task 3: Mount rigging routes</name>
  <files>server/index.js</files>
  <action>
Add rigging routes to server/index.js:

1. Import the routes at the top with other route imports:
```javascript
import riggingRoutes from './routes/rigging.js';
```

2. Mount the routes with other API routes (after shells routes is a good location):
```javascript
app.use('/api/v1/rigging', apiLimiter, riggingRoutes);
```
  </action>
  <verify>Run `npm run server` and test with curl:
  - `curl -X GET http://localhost:8000/api/v1/rigging/defaults` (should return 401 without auth, confirming route is mounted)
  </verify>
  <done>Rigging routes mounted at /api/v1/rigging.</done>
</task>

</tasks>

<verification>
- [ ] `node -c server/services/riggingService.js` passes
- [ ] `node -c server/routes/rigging.js` passes
- [ ] Server starts without errors
- [ ] GET /api/v1/rigging/defaults returns 401 (auth required)
- [ ] Routes are properly mounted in server/index.js
</verification>

<success_criteria>
1. Rigging service provides CRUD operations with team isolation
2. Default rigging values available for all standard boat classes
3. API endpoints follow existing project patterns
4. All routes require authentication
</success_criteria>

<output>
After completion, create `.planning/phases/18-lineup-boat-improvements/18-03-SUMMARY.md`
</output>
