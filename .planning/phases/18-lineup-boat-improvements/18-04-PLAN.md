---
phase: 18-lineup-boat-improvements
plan: 04
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - server/routes/lineupTemplates.js
  - server/services/lineupTemplateService.js
  - server/index.js
autonomous: true

must_haves:
  truths:
    - "Lineup templates can be saved, listed, applied, and deleted via API"
    - "Templates can be marked as default for a boat class"
    - "Applying a template creates lineup assignments from template data"
  artifacts:
    - path: "server/routes/lineupTemplates.js"
      provides: "REST API endpoints for template CRUD"
      exports: ["router"]
    - path: "server/services/lineupTemplateService.js"
      provides: "Business logic for template operations"
      exports: ["createTemplate", "getTemplates", "applyTemplate", "deleteTemplate"]
  key_links:
    - from: "server/routes/lineupTemplates.js"
      to: "server/services/lineupTemplateService.js"
      via: "Service function calls"
      pattern: "templateService\\."
---

<objective>
Create backend API for lineup template management.

Purpose: Enable coaches to save lineups as reusable templates (A-boat, B-boat, etc.) and apply them quickly.
Output: REST API endpoints for template CRUD and application operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-lineup-boat-improvements/18-RESEARCH.md
@prisma/schema.prisma
@server/routes/lineups.js
@server/services/lineupService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lineup template service</name>
  <files>server/services/lineupTemplateService.js</files>
  <action>
Create `server/services/lineupTemplateService.js` with:

```javascript
/**
 * Lineup Template Service - Phase 18 LINEUP-03
 *
 * Manages reusable lineup templates with team isolation.
 */

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Create a new lineup template
 */
export async function createTemplate(teamId, data) {
  // If setting as default, clear other defaults for this boat class
  if (data.isDefault) {
    await prisma.lineupTemplate.updateMany({
      where: {
        teamId,
        boatClass: data.boatClass,
        isDefault: true,
      },
      data: { isDefault: false },
    });
  }

  const template = await prisma.lineupTemplate.create({
    data: {
      teamId,
      name: data.name,
      description: data.description || null,
      boatClass: data.boatClass,
      assignments: data.assignments,
      rigging: data.rigging || null,
      isDefault: data.isDefault || false,
    },
  });

  return template;
}

/**
 * Create template from existing lineup
 */
export async function createTemplateFromLineup(teamId, lineupId, templateName, isDefault = false) {
  // Get the lineup with assignments
  const lineup = await prisma.lineup.findFirst({
    where: { id: lineupId, teamId },
    include: {
      assignments: {
        include: {
          athlete: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
        },
      },
    },
  });

  if (!lineup) {
    throw new Error('Lineup not found');
  }

  // Group assignments by boat class
  const boatClasses = [...new Set(lineup.assignments.map((a) => a.boatClass))];

  if (boatClasses.length === 0) {
    throw new Error('Lineup has no assignments');
  }

  // For simplicity, create template for first boat class
  // (In a more complex scenario, could create multiple templates)
  const boatClass = boatClasses[0];
  const boatAssignments = lineup.assignments.filter(
    (a) => a.boatClass === boatClass
  );

  const templateAssignments = boatAssignments.map((a) => ({
    seatNumber: a.seatNumber,
    side: a.side,
    isCoxswain: a.isCoxswain,
    preferredAthleteId: a.athleteId,
    preferredAthleteName: `${a.athlete.firstName} ${a.athlete.lastName}`,
  }));

  return createTemplate(teamId, {
    name: templateName,
    description: `Created from lineup: ${lineup.name}`,
    boatClass,
    assignments: templateAssignments,
    isDefault,
  });
}

/**
 * Get all templates for a team
 */
export async function getTemplates(teamId, boatClass = null) {
  const where = { teamId };
  if (boatClass) {
    where.boatClass = boatClass;
  }

  const templates = await prisma.lineupTemplate.findMany({
    where,
    orderBy: [{ isDefault: 'desc' }, { updatedAt: 'desc' }],
  });

  return templates;
}

/**
 * Get a single template by ID
 */
export async function getTemplateById(templateId, teamId) {
  const template = await prisma.lineupTemplate.findFirst({
    where: { id: templateId, teamId },
  });

  if (!template) {
    throw new Error('Template not found');
  }

  return template;
}

/**
 * Get default template for a boat class
 */
export async function getDefaultTemplate(teamId, boatClass) {
  const template = await prisma.lineupTemplate.findFirst({
    where: {
      teamId,
      boatClass,
      isDefault: true,
    },
  });

  return template;
}

/**
 * Update a template
 */
export async function updateTemplate(templateId, teamId, data) {
  const existing = await prisma.lineupTemplate.findFirst({
    where: { id: templateId, teamId },
  });

  if (!existing) {
    throw new Error('Template not found');
  }

  // If setting as default, clear other defaults for this boat class
  if (data.isDefault && !existing.isDefault) {
    await prisma.lineupTemplate.updateMany({
      where: {
        teamId,
        boatClass: existing.boatClass,
        isDefault: true,
      },
      data: { isDefault: false },
    });
  }

  const template = await prisma.lineupTemplate.update({
    where: { id: templateId },
    data: {
      name: data.name ?? existing.name,
      description: data.description ?? existing.description,
      assignments: data.assignments ?? existing.assignments,
      rigging: data.rigging ?? existing.rigging,
      isDefault: data.isDefault ?? existing.isDefault,
      updatedAt: new Date(),
    },
  });

  return template;
}

/**
 * Delete a template
 */
export async function deleteTemplate(templateId, teamId) {
  const template = await prisma.lineupTemplate.findFirst({
    where: { id: templateId, teamId },
  });

  if (!template) {
    throw new Error('Template not found');
  }

  await prisma.lineupTemplate.delete({
    where: { id: templateId },
  });

  return { success: true };
}

/**
 * Apply template to create/update a lineup's boat assignments
 * Returns assignment data ready to be added to lineupStore
 */
export async function applyTemplate(templateId, teamId, options = {}) {
  const template = await prisma.lineupTemplate.findFirst({
    where: { id: templateId, teamId },
  });

  if (!template) {
    throw new Error('Template not found');
  }

  // Get available athletes if we need to resolve preferred athletes
  const athletes = await prisma.athlete.findMany({
    where: { teamId },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      side: true,
      canCox: true,
    },
  });

  const athleteMap = new Map(athletes.map((a) => [a.id, a]));

  // Process template assignments
  const assignedAthletes = [];
  const unfilledSeats = [];

  for (const assignment of template.assignments) {
    if (assignment.preferredAthleteId) {
      const athlete = athleteMap.get(assignment.preferredAthleteId);
      if (athlete) {
        // Check if already assigned in this template application
        const alreadyAssigned = assignedAthletes.some(
          (a) => a.athleteId === athlete.id
        );
        if (!alreadyAssigned) {
          assignedAthletes.push({
            seatNumber: assignment.seatNumber,
            side: assignment.side,
            isCoxswain: assignment.isCoxswain || false,
            athleteId: athlete.id,
            athleteName: `${athlete.firstName} ${athlete.lastName}`,
            isPreferred: true,
          });
          continue;
        }
      }
    }

    // Preferred athlete not found or not available
    unfilledSeats.push(assignment.seatNumber);
  }

  return {
    templateId: template.id,
    templateName: template.name,
    boatClass: template.boatClass,
    assignedAthletes,
    unfilledSeats,
    rigging: template.rigging,
  };
}
```
  </action>
  <verify>Run `node -c server/services/lineupTemplateService.js` - should parse without syntax errors.</verify>
  <done>Template service created with create, get, update, delete, apply functions.</done>
</task>

<task type="auto">
  <name>Task 2: Create lineup template routes</name>
  <files>server/routes/lineupTemplates.js</files>
  <action>
Create `server/routes/lineupTemplates.js` with:

```javascript
/**
 * Lineup Template Routes - Phase 18 LINEUP-03
 *
 * Endpoints:
 * GET    /api/v1/lineup-templates              - List all templates
 * GET    /api/v1/lineup-templates/:id          - Get single template
 * POST   /api/v1/lineup-templates              - Create new template
 * POST   /api/v1/lineup-templates/from-lineup  - Create template from existing lineup
 * PUT    /api/v1/lineup-templates/:id          - Update template
 * DELETE /api/v1/lineup-templates/:id          - Delete template
 * POST   /api/v1/lineup-templates/:id/apply    - Apply template to get assignments
 */

import express from 'express';
import { param, body, query } from 'express-validator';
import { authenticateToken, requireTeam } from '../middleware/auth.js';
import { validateRequest } from '../middleware/validation.js';
import * as templateService from '../services/lineupTemplateService.js';
import { logger } from '../utils/logger.js';

const router = express.Router();

/**
 * GET /api/v1/lineup-templates
 * List all templates, optionally filtered by boat class
 */
router.get(
  '/',
  authenticateToken,
  requireTeam,
  [query('boatClass').optional().isString()],
  validateRequest,
  async (req, res) => {
    try {
      const templates = await templateService.getTemplates(
        req.user.activeTeamId,
        req.query.boatClass || null
      );
      res.json({ success: true, data: { templates } });
    } catch (error) {
      logger.error('Error fetching templates:', error);
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * GET /api/v1/lineup-templates/:id
 * Get a single template
 */
router.get(
  '/:id',
  authenticateToken,
  requireTeam,
  [param('id').isString().notEmpty()],
  validateRequest,
  async (req, res) => {
    try {
      const template = await templateService.getTemplateById(
        req.params.id,
        req.user.activeTeamId
      );
      res.json({ success: true, data: { template } });
    } catch (error) {
      logger.error('Error fetching template:', error);
      if (error.message === 'Template not found') {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Template not found' },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * POST /api/v1/lineup-templates
 * Create a new template
 */
router.post(
  '/',
  authenticateToken,
  requireTeam,
  [
    body('name').isString().notEmpty().trim(),
    body('description').optional().isString().trim(),
    body('boatClass').isString().notEmpty(),
    body('assignments').isArray().notEmpty(),
    body('assignments.*.seatNumber').isInt({ min: 0 }),
    body('assignments.*.side').isIn(['Port', 'Starboard']),
    body('assignments.*.preferredAthleteId').optional().isString(),
    body('rigging').optional().isObject(),
    body('isDefault').optional().isBoolean(),
  ],
  validateRequest,
  async (req, res) => {
    try {
      const template = await templateService.createTemplate(
        req.user.activeTeamId,
        req.body
      );
      res.status(201).json({ success: true, data: { template } });
    } catch (error) {
      logger.error('Error creating template:', error);
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * POST /api/v1/lineup-templates/from-lineup
 * Create template from existing lineup
 */
router.post(
  '/from-lineup',
  authenticateToken,
  requireTeam,
  [
    body('lineupId').isString().notEmpty(),
    body('name').isString().notEmpty().trim(),
    body('isDefault').optional().isBoolean(),
  ],
  validateRequest,
  async (req, res) => {
    try {
      const template = await templateService.createTemplateFromLineup(
        req.user.activeTeamId,
        req.body.lineupId,
        req.body.name,
        req.body.isDefault || false
      );
      res.status(201).json({ success: true, data: { template } });
    } catch (error) {
      logger.error('Error creating template from lineup:', error);
      if (error.message === 'Lineup not found') {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Lineup not found' },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * PUT /api/v1/lineup-templates/:id
 * Update a template
 */
router.put(
  '/:id',
  authenticateToken,
  requireTeam,
  [
    param('id').isString().notEmpty(),
    body('name').optional().isString().trim(),
    body('description').optional().isString().trim(),
    body('assignments').optional().isArray(),
    body('rigging').optional().isObject(),
    body('isDefault').optional().isBoolean(),
  ],
  validateRequest,
  async (req, res) => {
    try {
      const template = await templateService.updateTemplate(
        req.params.id,
        req.user.activeTeamId,
        req.body
      );
      res.json({ success: true, data: { template } });
    } catch (error) {
      logger.error('Error updating template:', error);
      if (error.message === 'Template not found') {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Template not found' },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * DELETE /api/v1/lineup-templates/:id
 * Delete a template
 */
router.delete(
  '/:id',
  authenticateToken,
  requireTeam,
  [param('id').isString().notEmpty()],
  validateRequest,
  async (req, res) => {
    try {
      await templateService.deleteTemplate(
        req.params.id,
        req.user.activeTeamId
      );
      res.json({ success: true, data: { message: 'Template deleted' } });
    } catch (error) {
      logger.error('Error deleting template:', error);
      if (error.message === 'Template not found') {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Template not found' },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

/**
 * POST /api/v1/lineup-templates/:id/apply
 * Apply template to get assignments
 */
router.post(
  '/:id/apply',
  authenticateToken,
  requireTeam,
  [param('id').isString().notEmpty()],
  validateRequest,
  async (req, res) => {
    try {
      const result = await templateService.applyTemplate(
        req.params.id,
        req.user.activeTeamId
      );
      res.json({ success: true, data: result });
    } catch (error) {
      logger.error('Error applying template:', error);
      if (error.message === 'Template not found') {
        return res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Template not found' },
        });
      }
      res.status(500).json({
        success: false,
        error: { code: 'SERVER_ERROR', message: error.message },
      });
    }
  }
);

export default router;
```
  </action>
  <verify>Run `node -c server/routes/lineupTemplates.js` - should parse without syntax errors.</verify>
  <done>Template routes created with full CRUD + apply endpoint.</done>
</task>

<task type="auto">
  <name>Task 3: Mount template routes</name>
  <files>server/index.js</files>
  <action>
Add lineup template routes to server/index.js:

1. Import the routes at the top with other route imports:
```javascript
import lineupTemplateRoutes from './routes/lineupTemplates.js';
```

2. Mount the routes with other API routes (near lineup routes):
```javascript
app.use('/api/v1/lineup-templates', apiLimiter, lineupTemplateRoutes);
```
  </action>
  <verify>Server starts without errors. `curl -X GET http://localhost:8000/api/v1/lineup-templates` returns 401.</verify>
  <done>Template routes mounted at /api/v1/lineup-templates.</done>
</task>

</tasks>

<verification>
- [ ] `node -c server/services/lineupTemplateService.js` passes
- [ ] `node -c server/routes/lineupTemplates.js` passes
- [ ] Server starts without errors
- [ ] GET /api/v1/lineup-templates returns 401 (auth required)
</verification>

<success_criteria>
1. Template service provides full CRUD operations
2. Templates can be created from existing lineups
3. Applying templates resolves athlete assignments
4. Default template per boat class supported
</success_criteria>

<output>
After completion, create `.planning/phases/18-lineup-boat-improvements/18-04-SUMMARY.md`
</output>
