---
phase: 18-lineup-boat-improvements
plan: 11
type: execute
wave: 4
depends_on: ["18-02"]
files_modified:
  - src/v2/utils/lineupExcelExport.ts
  - src/v2/utils/lineupPdfExport.ts
autonomous: true

must_haves:
  truths:
    - "Excel export generates .xlsx file with lineup data"
    - "PDF export includes QR code linking to digital version"
    - "Excel library is lazy-loaded to avoid bundle bloat"
  artifacts:
    - path: "src/v2/utils/lineupExcelExport.ts"
      provides: "Excel export with lazy-loaded xlsx"
      exports: ["exportLineupToExcel"]
    - path: "src/v2/utils/lineupPdfExport.ts"
      provides: "Enhanced PDF export with QR code"
      exports: ["exportEnhancedLineupPdf"]
  key_links:
    - from: "src/v2/utils/lineupExcelExport.ts"
      to: "xlsx"
      via: "Dynamic import"
      pattern: "import\\('xlsx'\\)"
    - from: "src/v2/utils/lineupPdfExport.ts"
      to: "qrcode.react"
      via: "QRCodeSVG import"
      pattern: "QRCodeSVG"
---

<objective>
Create enhanced export utilities with Excel support and QR codes in PDFs.

Purpose: Enable coaches to export lineups to Excel for external tools and include QR codes in PDFs for easy digital access.
Output: Two utility files with export functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-lineup-boat-improvements/18-RESEARCH.md
@src/v2/types/rigging.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Excel export utility</name>
  <files>src/v2/utils/lineupExcelExport.ts</files>
  <action>
Create `src/v2/utils/lineupExcelExport.ts`:

```typescript
/**
 * Lineup Excel Export - Phase 18 LINEUP-05
 *
 * Exports lineup data to Excel format with optional rigging and equipment sheets.
 * Uses lazy-loaded xlsx library to avoid bundle bloat (~400kb).
 */

import type { RiggingDefaults } from '@v2/types/rigging';

interface Athlete {
  id: string;
  firstName: string;
  lastName: string;
  weightKg?: number | null;
  side?: string | null;
}

interface Seat {
  seatNumber: number;
  side: 'Port' | 'Starboard';
  athlete: Athlete | null;
  isCoxswain?: boolean;
}

interface Boat {
  id: string;
  name: string;
  shellName?: string | null;
  seats: Seat[];
  coxswain?: Athlete | null;
}

interface LineupExportData {
  name: string;
  notes?: string | null;
  boats: Boat[];
  rigging?: Record<string, RiggingDefaults>;
  equipment?: Array<{
    shellName: string;
    oarSetName?: string | null;
  }>;
}

interface ExportOptions {
  includeRigging?: boolean;
  includeEquipment?: boolean;
  includeAthleteDetails?: boolean;
}

/**
 * Export lineup to Excel file
 *
 * Lazy loads xlsx library on first use to avoid bundle bloat.
 */
export async function exportLineupToExcel(
  lineup: LineupExportData,
  options: ExportOptions = {}
): Promise<void> {
  // Lazy load xlsx library (~400kb)
  const XLSX = await import('xlsx');

  const workbook = XLSX.utils.book_new();

  // Sheet 1: Lineup Assignments
  const lineupRows: Array<Record<string, string | number | null>> = [];

  for (const boat of lineup.boats) {
    // Add seats (stroke to bow)
    const sortedSeats = [...boat.seats].sort((a, b) => b.seatNumber - a.seatNumber);

    for (const seat of sortedSeats) {
      const row: Record<string, string | number | null> = {
        'Boat Class': boat.name,
        'Shell': boat.shellName || '',
        'Seat': seat.seatNumber,
        'Side': seat.side,
        'Athlete': seat.athlete
          ? `${seat.athlete.firstName} ${seat.athlete.lastName}`
          : '',
      };

      if (options.includeAthleteDetails && seat.athlete) {
        row['Weight (kg)'] = seat.athlete.weightKg ?? '';
        row['Side Pref'] = seat.athlete.side || '';
      }

      lineupRows.push(row);
    }

    // Add coxswain if present
    if (boat.coxswain) {
      const row: Record<string, string | number | null> = {
        'Boat Class': boat.name,
        'Shell': boat.shellName || '',
        'Seat': 'Cox',
        'Side': '',
        'Athlete': `${boat.coxswain.firstName} ${boat.coxswain.lastName}`,
      };

      if (options.includeAthleteDetails) {
        row['Weight (kg)'] = boat.coxswain.weightKg ?? '';
        row['Side Pref'] = 'Cox';
      }

      lineupRows.push(row);
    }

    // Add empty row between boats
    if (lineup.boats.indexOf(boat) < lineup.boats.length - 1) {
      lineupRows.push({});
    }
  }

  const lineupSheet = XLSX.utils.json_to_sheet(lineupRows);

  // Set column widths
  lineupSheet['!cols'] = [
    { wch: 12 }, // Boat Class
    { wch: 15 }, // Shell
    { wch: 6 },  // Seat
    { wch: 10 }, // Side
    { wch: 25 }, // Athlete
    { wch: 12 }, // Weight
    { wch: 12 }, // Side Pref
  ];

  XLSX.utils.book_append_sheet(workbook, lineupSheet, 'Lineup');

  // Sheet 2: Rigging (optional)
  if (options.includeRigging && lineup.rigging) {
    const riggingRows: Array<Record<string, string | number>> = [];

    for (const [shellName, rigging] of Object.entries(lineup.rigging)) {
      riggingRows.push({
        'Shell': shellName,
        'Spread/Span (cm)': rigging.spread ?? rigging.span ?? '',
        'Catch Angle (deg)': rigging.catchAngle ?? '',
        'Finish Angle (deg)': rigging.finishAngle ?? '',
        'Oar Length (cm)': rigging.oarLength ?? '',
        'Inboard (cm)': rigging.inboard ?? '',
        'Pitch (deg)': rigging.pitch ?? '',
        'Gate Height (mm)': rigging.gateHeight ?? '',
      });
    }

    if (riggingRows.length > 0) {
      const riggingSheet = XLSX.utils.json_to_sheet(riggingRows);
      riggingSheet['!cols'] = [
        { wch: 15 }, // Shell
        { wch: 15 }, // Spread/Span
        { wch: 15 }, // Catch
        { wch: 15 }, // Finish
        { wch: 15 }, // Oar Length
        { wch: 12 }, // Inboard
        { wch: 10 }, // Pitch
        { wch: 15 }, // Gate Height
      ];
      XLSX.utils.book_append_sheet(workbook, riggingSheet, 'Rigging');
    }
  }

  // Sheet 3: Equipment (optional)
  if (options.includeEquipment && lineup.equipment && lineup.equipment.length > 0) {
    const equipmentRows = lineup.equipment.map((e) => ({
      'Shell': e.shellName,
      'Oar Set': e.oarSetName || '',
    }));

    const equipmentSheet = XLSX.utils.json_to_sheet(equipmentRows);
    equipmentSheet['!cols'] = [
      { wch: 15 }, // Shell
      { wch: 20 }, // Oar Set
    ];
    XLSX.utils.book_append_sheet(workbook, equipmentSheet, 'Equipment');
  }

  // Generate filename
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `${lineup.name.replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp}.xlsx`;

  // Write and download
  XLSX.writeFile(workbook, filename);
}

/**
 * Generate preview data for export (without triggering download)
 */
export function generateExportPreview(
  lineup: LineupExportData,
  options: ExportOptions = {}
): {
  lineupRowCount: number;
  sheetsCount: number;
  estimatedSize: string;
} {
  let rowCount = 0;
  for (const boat of lineup.boats) {
    rowCount += boat.seats.length + (boat.coxswain ? 1 : 0);
  }

  let sheetsCount = 1;
  if (options.includeRigging && lineup.rigging) sheetsCount++;
  if (options.includeEquipment && lineup.equipment?.length) sheetsCount++;

  // Rough estimate: ~500 bytes per row + overhead
  const estimatedBytes = rowCount * 500 + sheetsCount * 1000;
  const estimatedSize =
    estimatedBytes > 1024
      ? `${(estimatedBytes / 1024).toFixed(1)} KB`
      : `${estimatedBytes} bytes`;

  return {
    lineupRowCount: rowCount,
    sheetsCount,
    estimatedSize,
  };
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/v2/utils/lineupExcelExport.ts` - should compile without errors.</verify>
  <done>Excel export utility created with lazy-loaded xlsx library.</done>
</task>

<task type="auto">
  <name>Task 2: Update PDF export with QR code support</name>
  <files>src/v2/utils/lineupPdfExport.ts</files>
  <action>
Check if `src/v2/utils/lineupPdfExport.ts` exists. If it does, add QR code support. If not, create it.

Create/update `src/v2/utils/lineupPdfExport.ts`:

```typescript
/**
 * Lineup PDF Export - Phase 18 LINEUP-05 (Enhanced)
 *
 * Enhanced PDF export with QR codes linking to digital lineup version.
 */

import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';

interface ExportPdfOptions {
  includeQRCode?: boolean;
  lineupId?: string;
  baseUrl?: string;
}

/**
 * Convert a React QR code element to a data URL
 */
async function qrCodeToDataUrl(lineupId: string, baseUrl: string): Promise<string> {
  // Create a temporary container
  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.left = '-9999px';
  container.style.background = 'white';
  container.style.padding = '8px';
  document.body.appendChild(container);

  // Dynamically import qrcode.react and render
  const { QRCodeCanvas } = await import('qrcode.react');
  const { createRoot } = await import('react-dom/client');
  const React = await import('react');

  const url = `${baseUrl}/lineups/${lineupId}/view`;

  return new Promise((resolve) => {
    const root = createRoot(container);
    root.render(
      React.createElement(QRCodeCanvas, {
        value: url,
        size: 100,
        level: 'H',
        includeMargin: true,
        // Use callback to get data URL when rendered
        bgColor: '#ffffff',
        fgColor: '#000000',
      })
    );

    // Wait for render then extract canvas
    setTimeout(() => {
      const canvas = container.querySelector('canvas');
      if (canvas) {
        resolve(canvas.toDataURL('image/png'));
      } else {
        resolve('');
      }
      root.unmount();
      document.body.removeChild(container);
    }, 100);
  });
}

/**
 * Export lineup container element to PDF with optional QR code
 *
 * @param element - The DOM element containing the lineup visual
 * @param filename - Output filename (without .pdf extension)
 * @param options - Export options including QR code settings
 */
export async function exportLineupToPdf(
  element: HTMLElement,
  filename: string,
  options: ExportPdfOptions = {}
): Promise<void> {
  const { includeQRCode = false, lineupId, baseUrl = window.location.origin } = options;

  // Capture element as canvas
  const canvas = await html2canvas(element, {
    scale: 2, // Higher resolution
    useCORS: true,
    allowTaint: true,
    backgroundColor: '#ffffff',
  });

  const imgWidth = 210; // A4 width in mm
  const pageHeight = 297; // A4 height in mm
  const imgHeight = (canvas.height * imgWidth) / canvas.width;

  const pdf = new jsPDF('p', 'mm', 'a4');

  // Add lineup image
  const imgData = canvas.toDataURL('image/png');
  pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);

  // Add QR code if requested
  if (includeQRCode && lineupId) {
    try {
      const qrDataUrl = await qrCodeToDataUrl(lineupId, baseUrl);
      if (qrDataUrl) {
        // Position QR code in bottom right corner
        const qrSize = 25; // mm
        const qrX = imgWidth - qrSize - 10; // 10mm margin from right
        const qrY = Math.min(imgHeight + 5, pageHeight - qrSize - 10); // Below content or near bottom

        pdf.addImage(qrDataUrl, 'PNG', qrX, qrY, qrSize, qrSize);

        // Add small label under QR code
        pdf.setFontSize(6);
        pdf.setTextColor(128, 128, 128);
        pdf.text('Scan for digital version', qrX + qrSize / 2, qrY + qrSize + 3, {
          align: 'center',
        });
      }
    } catch (error) {
      console.warn('Failed to add QR code to PDF:', error);
      // Continue without QR code
    }
  }

  // Save the PDF
  pdf.save(`${filename}.pdf`);
}

/**
 * Export multiple boats to a single PDF (multiple boats per page)
 */
export async function exportMultiBoatPdf(
  elements: HTMLElement[],
  filename: string,
  options: ExportPdfOptions = {}
): Promise<void> {
  const { includeQRCode = false, lineupId, baseUrl = window.location.origin } = options;

  const pdf = new jsPDF('p', 'mm', 'a4');
  const imgWidth = 210;
  const pageHeight = 297;
  const margin = 10;
  let currentY = margin;

  for (let i = 0; i < elements.length; i++) {
    const element = elements[i];

    const canvas = await html2canvas(element, {
      scale: 2,
      useCORS: true,
      allowTaint: true,
      backgroundColor: '#ffffff',
    });

    const aspectRatio = canvas.width / canvas.height;
    const imgW = imgWidth - margin * 2;
    const imgH = imgW / aspectRatio;

    // Check if we need a new page
    if (currentY + imgH > pageHeight - margin) {
      pdf.addPage();
      currentY = margin;
    }

    const imgData = canvas.toDataURL('image/png');
    pdf.addImage(imgData, 'PNG', margin, currentY, imgW, imgH);
    currentY += imgH + 5; // 5mm gap between boats
  }

  // Add QR code on last page if requested
  if (includeQRCode && lineupId) {
    try {
      const qrDataUrl = await qrCodeToDataUrl(lineupId, baseUrl);
      if (qrDataUrl) {
        const qrSize = 20;
        const qrX = imgWidth - qrSize - margin;
        const qrY = pageHeight - qrSize - margin;

        pdf.addImage(qrDataUrl, 'PNG', qrX, qrY, qrSize, qrSize);
        pdf.setFontSize(6);
        pdf.setTextColor(128, 128, 128);
        pdf.text('Scan for digital version', qrX + qrSize / 2, qrY + qrSize + 2, {
          align: 'center',
        });
      }
    } catch (error) {
      console.warn('Failed to add QR code to PDF:', error);
    }
  }

  pdf.save(`${filename}.pdf`);
}

/**
 * Simple PDF export without QR code (backward compatible)
 */
export async function exportSimplePdf(
  element: HTMLElement,
  filename: string
): Promise<void> {
  return exportLineupToPdf(element, filename, { includeQRCode: false });
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/v2/utils/lineupPdfExport.ts` - should compile without errors.</verify>
  <done>PDF export utility enhanced with QR code support.</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit src/v2/utils/lineupExcelExport.ts` passes
- [ ] `npx tsc --noEmit src/v2/utils/lineupPdfExport.ts` passes
- [ ] Excel export uses dynamic import for xlsx
- [ ] PDF export includes QR code option
- [ ] QR code links to correct URL
</verification>

<success_criteria>
1. Excel export generates valid .xlsx file
2. xlsx library is lazy-loaded (not in main bundle)
3. PDF export can include QR code
4. QR code is positioned correctly and scannable
5. Both exports handle multiple boats
</success_criteria>

<output>
After completion, create `.planning/phases/18-lineup-boat-improvements/18-11-SUMMARY.md`
</output>
